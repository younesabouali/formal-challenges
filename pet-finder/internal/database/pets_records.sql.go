// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: pets_records.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getMissingPetsEvent = `-- name: GetMissingPetsEvent :many
SELECT missing_pets.id, missing_pets.createdat, missing_pets.updatedat, pet_name, missing_pets.description, missing_pets.image_url, status, lost_in, lost_at, missing_pets.user_id, pets_records.id, pets_records.createdat, pets_records.updatedat, pet_id, pets_records.user_id, event_name, pets_records.image_url, pets_records.description, event_location, area, event_time FROM missing_pets INNER JOIN pets_records ON pets_records.pet_id=missing_pets.id WHERE missing_pets.id=$1
`

type GetMissingPetsEventRow struct {
	ID            uuid.UUID
	Createdat     time.Time
	Updatedat     time.Time
	PetName       string
	Description   sql.NullString
	ImageUrl      sql.NullString
	Status        MissingPetsStatus
	LostIn        interface{}
	LostAt        time.Time
	UserID        uuid.UUID
	ID_2          uuid.UUID
	Createdat_2   time.Time
	Updatedat_2   time.Time
	PetID         uuid.UUID
	UserID_2      uuid.UUID
	EventName     EventNames
	ImageUrl_2    sql.NullString
	Description_2 sql.NullString
	EventLocation interface{}
	Area          interface{}
	EventTime     sql.NullTime
}

func (q *Queries) GetMissingPetsEvent(ctx context.Context, id uuid.UUID) ([]GetMissingPetsEventRow, error) {
	rows, err := q.db.QueryContext(ctx, getMissingPetsEvent, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMissingPetsEventRow
	for rows.Next() {
		var i GetMissingPetsEventRow
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.PetName,
			&i.Description,
			&i.ImageUrl,
			&i.Status,
			&i.LostIn,
			&i.LostAt,
			&i.UserID,
			&i.ID_2,
			&i.Createdat_2,
			&i.Updatedat_2,
			&i.PetID,
			&i.UserID_2,
			&i.EventName,
			&i.ImageUrl_2,
			&i.Description_2,
			&i.EventLocation,
			&i.Area,
			&i.EventTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordEvent = `-- name: RecordEvent :one
INSERT INTO pets_records(
  id, createdAt, updatedAt,
  pet_id,user_id,
  event_name,image_url,description,
  event_location,event_time,area
)
VALUES (
  $1,$2,$3,
  $4,$5,
  $6,$7,$8,
  $9,$10,$11
)
RETURNING id, createdat, updatedat, pet_id, user_id, event_name, image_url, description, event_location, area, event_time
`

type RecordEventParams struct {
	ID            uuid.UUID
	Createdat     time.Time
	Updatedat     time.Time
	PetID         uuid.UUID
	UserID        uuid.UUID
	EventName     EventNames
	ImageUrl      sql.NullString
	Description   sql.NullString
	EventLocation interface{}
	EventTime     sql.NullTime
	Area          interface{}
}

func (q *Queries) RecordEvent(ctx context.Context, arg RecordEventParams) (PetsRecord, error) {
	row := q.db.QueryRowContext(ctx, recordEvent,
		arg.ID,
		arg.Createdat,
		arg.Updatedat,
		arg.PetID,
		arg.UserID,
		arg.EventName,
		arg.ImageUrl,
		arg.Description,
		arg.EventLocation,
		arg.EventTime,
		arg.Area,
	)
	var i PetsRecord
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.PetID,
		&i.UserID,
		&i.EventName,
		&i.ImageUrl,
		&i.Description,
		&i.EventLocation,
		&i.Area,
		&i.EventTime,
	)
	return i, err
}
