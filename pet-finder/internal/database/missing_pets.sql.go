// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: missing_pets.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createMissingPet = `-- name: CreateMissingPet :one
INSERT INTO missing_pets (
  id, createdAt,updatedAt,
  pet_name,description, image_url,
  status,lost_in,lost_at,
  user_id
)
VALUES ($1,$2,$3,
  $4,$5, $6,
  $7,$8,$9,
  $10)
returning id, createdat, updatedat, pet_name, description, image_url, status, lost_in, lost_at, user_id
`

type CreateMissingPetParams struct {
	ID          uuid.UUID
	Createdat   time.Time
	Updatedat   time.Time
	PetName     string
	Description sql.NullString
	ImageUrl    sql.NullString
	Status      MissingPetsStatus
	LostIn      interface{}
	LostAt      time.Time
	UserID      uuid.UUID
}

func (q *Queries) CreateMissingPet(ctx context.Context, arg CreateMissingPetParams) (MissingPet, error) {
	row := q.db.QueryRowContext(ctx, createMissingPet,
		arg.ID,
		arg.Createdat,
		arg.Updatedat,
		arg.PetName,
		arg.Description,
		arg.ImageUrl,
		arg.Status,
		arg.LostIn,
		arg.LostAt,
		arg.UserID,
	)
	var i MissingPet
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.PetName,
		&i.Description,
		&i.ImageUrl,
		&i.Status,
		&i.LostIn,
		&i.LostAt,
		&i.UserID,
	)
	return i, err
}

const getMissingPets = `-- name: GetMissingPets :many
SELECT id, createdat, updatedat, pet_name, description, image_url, status, lost_in, lost_at, user_id
FROM missing_pets
WHERE status = 'missing' AND
      ST_Distance(lost_in, ST_SetSRID(ST_MakePoint($1,$2), 4326)) <= $3 LIMIT $4 OFFSET $5
`

type GetMissingPetsParams struct {
	StMakepoint   interface{}
	StMakepoint_2 interface{}
	LostIn        interface{}
	Limit         int32
	Offset        int32
}

func (q *Queries) GetMissingPets(ctx context.Context, arg GetMissingPetsParams) ([]MissingPet, error) {
	rows, err := q.db.QueryContext(ctx, getMissingPets,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.LostIn,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MissingPet
	for rows.Next() {
		var i MissingPet
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.PetName,
			&i.Description,
			&i.ImageUrl,
			&i.Status,
			&i.LostIn,
			&i.LostAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPetAsFound = `-- name: SetPetAsFound :one
UPDATE missing_pets SET status='found' WHERE id =$1 AND user_id=$2 
RETURNING id, createdat, updatedat, pet_name, description, image_url, status, lost_in, lost_at, user_id
`

type SetPetAsFoundParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) SetPetAsFound(ctx context.Context, arg SetPetAsFoundParams) (MissingPet, error) {
	row := q.db.QueryRowContext(ctx, setPetAsFound, arg.ID, arg.UserID)
	var i MissingPet
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.PetName,
		&i.Description,
		&i.ImageUrl,
		&i.Status,
		&i.LostIn,
		&i.LostAt,
		&i.UserID,
	)
	return i, err
}
